**1. 概要**

1.1. **プロジェクト名:** (例: Anki風Webアプリ LLM連携拡張)
1.2. **目的:**
    *   ユーザーが保有するカード情報（表裏データ）から、LLMを利用して多様な形式（4択、穴埋め、自由記述など）の問題を自動生成する機能を提供する。
    *   初回演習時に問題を生成し、以降はキャッシュを利用することで、LLM利用コストと生成時間を削減し、UXを向上させる。
    *   有料ユーザー向けに、カード作成/編集時に事前問題生成を行う特典機能を提供する。
1.3. **背景:**
    *   従来のカード形式に加え、多様な問題形式での演習を可能にすることで学習効果を高める。
    *   演習の都度LLMで問題を生成すると、コストと待ち時間が発生しUXを損なうため、効率的な問題生成・管理の仕組みが必要。

**2. スコープ**

2.1. **対象機能:**
    *   LLMによる問題データの生成処理（指定された問題形式）。
    *   生成された問題データのデータベースへの保存（キャッシュ）。
    *   演習時の問題データ読み込み処理。
    *   カード内容更新時の、関連する古い問題データの削除処理。
    *   無料ユーザー向け: 初回演習時のオンデマンド問題生成。
    *   有料ユーザー向け: カード作成/編集時のバックグラウンドでの事前問題生成。
    *   有料ユーザー向け: 事前生成する問題形式の選択機能（設定画面）。
2.2. **対象外機能 (将来検討):**
    *   ユーザーによる生成済み問題の編集機能。
    *   生成された問題の品質評価・フィードバック機能。
    *   LLM以外の手段による問題生成。
    *   非常に複雑な問題形式の生成（例: 図を含む問題など、初期段階ではシンプルなものから）。

**3. ユーザー種別と主要ユースケース**

3.1. **無料ユーザー**
    *   UC-Free-01: カードを作成/編集する。
    *   UC-Free-02: カードを指定し、特定の問題形式で演習を開始する。
        *   システムは、該当カード・問題形式の生成済み問題がDBに存在するか確認する。
        *   存在しない場合、LLMに問題生成をリクエストし、生成中にローディングを表示する。
        *   生成された問題データをDBに保存し、ユーザーに提示する。
        *   存在する場合、DBから問題データを読み込み、即座にユーザーに提示する。
    *   UC-Free-03: カードの内容を更新する。
        *   システムは、更新されたカードに関連する全ての生成済み問題データをDBから削除する。（再生成はUC-Free-02のフローで行う）
3.2. **有料ユーザー**
    *   UC-Paid-01: 無料ユーザーの全てのユースケースを実行できる。
    *   UC-Paid-02: アプリケーションの設定画面で、カード作成/編集時にバックグラウンドで事前生成する問題形式を選択・保存する。
    *   UC-Paid-03: カードを新規作成または編集・保存する。
        *   システムは、UC-Paid-02で設定された問題形式について、バックグラウンドでLLMに問題生成をリクエストする。
        *   生成された問題データはDBに保存される。ユーザーは生成完了を待つ必要はない。
    *   UC-Paid-04: カードを指定し、特定の問題形式で演習を開始する。
        *   （UC-Paid-03により事前生成されている可能性が高いため）多くの場合、DBから問題データを読み込み、即座にユーザーに提示できる。
        *   万が一、事前生成が間に合わなかったり、設定外の問題形式を選択した場合は、UC-Free-02と同様のオンデマンド生成フローとなる。

**4. 機能要件**

4.1. **カード管理機能 (前提)**
    *   4.1.1. ユーザーはカードを作成、編集、削除できる。
    *   4.1.2. カードは表（`front_content`）、裏（`back_content`）の情報を持つ (JSONB形式)。
    *   4.1.3. カードはデッキに所属する。
4.2. **LLM問題生成機能**
    *   4.2.1. システムは、カードの `front_content` と `back_content` および指定された問題形式を基に、LLMに適切なプロンプトを送信できる。
    *   4.2.2. 対応する問題形式: (例: `multiple_choice` (4択), `fill_in_the_blank` (穴埋め), `free_description` (自由記述) - 具体的な形式名を定義する)
    *   4.2.3. LLMからのレスポンス（問題データ）をパースし、`questions.question_data` (JSONB) に格納可能な形式に整形できる。
    *   4.2.4. LLM APIキーは環境変数等で安全に管理される。
    *   4.2.5. LLM API呼び出し時のエラー（APIエラー、タイムアウト、コンテンツフィルター等）を適切にハンドリングし、ログに記録する。
    *   4.2.6. 生成された問題には、使用したLLMモデル名 (`llm_model_used`) を記録する。
4.3. **問題キャッシュ（保存・読込）機能**
    *   4.3.1. 生成された問題データは、`questions` テーブルに保存される。必須カラム: `card_id`, `type`, `question_data`, `llm_model_used`, `created_at`。
    *   4.3.2. 演習開始時、`cards.id` と問題形式 (`questions.type`) をキーに、`questions` テーブルを検索し、該当する問題データを取得する。
4.4. **問題再生成管理機能**
    *   4.4.1. `cards` テーブルのレコードが更新（`front_content` または `back_content` の変更）された場合、該当 `card_id` に関連付けられている全てのレコードを `questions` テーブルから削除する。
4.5. **バックグラウンド処理機能 (有料ユーザー向け)**
    *   4.5.1. 有料ユーザーがカードを新規作成または編集・保存した際、設定された問題形式について非同期で問題生成タスクを起動する。
    *   4.5.2. バックグラウンド処理にはジョブキューシステム（例: Supabase Edge Functionsの非同期呼び出し、または外部キューサービスを検討）を利用する。
    *   4.5.3. バックグラウンド処理の成功・失敗はログに記録する。
4.6. **ユーザープラン識別機能**
    *   4.6.1. システムは、現在のユーザーが無料ユーザーか有料ユーザーかを識別できる。
    *   4.6.2. 識別情報に基づき、問題生成のタイミングや設定機能の利用可否を制御する。
4.7. **設定機能 (有料ユーザー向け)**
    *   4.7.1. 有料ユーザーは、カード作成/編集時に自動で事前生成する問題形式（4.2.2で定義されたものから複数選択可）を設定できる専用UIを持つ。
    *   4.7.2. 設定内容はユーザーごとに永続化される。
4.8. **演習画面機能**
    *   4.8.1. 取得した問題データ (`question_data`) を基に、問題形式に応じた適切なUIで問題を表示する。
    *   4.8.2. ユーザーが解答を入力/選択できるインターフェースを提供する。
    *   4.8.3. （問題形式に応じて）正誤判定ロジックを持つ (本要件定義の主スコープ外だが、問題データ構造に影響するため考慮)。

**5. 非機能要件**

5.1. **パフォーマンス・UX**
    *   5.1.1. キャッシュ利用時の問題表示: 1秒以内を目指す。
    *   5.1.2. オンデマンド問題生成時: 生成中であることを示すローディングインジケーターを表示し、ユーザーが待ち時間を認識できるようにする。許容時間はLLMの応答速度に依存するが、最大でも10-15秒程度を目標とし、それ以上かかる場合はタイムアウト処理やエラーメッセージを検討する。
    *   5.1.3. バックグラウンド処理: ユーザー操作をブロックしないこと。
5.2. **セキュリティ**
    *   5.2.1. LLM APIキーはクライアントサイドに公開せず、サーバーサイドで安全に管理する。
    *   5.2.2. `questions` テーブルに対するRLSポリシーを再定義し、ユーザーは自分が所有するカードに関連する問題データにのみアクセスできるようにする。(例: `EXISTS (SELECT 1 FROM cards c WHERE c.id = questions.card_id AND c.user_id = auth.uid())`)
    *   5.2.3. ユーザー入力（カード内容）をLLMに渡す際のサニタイズ処理を検討（プロンプトインジェクション対策）。
5.3. **コスト管理**
    *   5.3.1. LLM APIのコール数を最小限に抑える設計とする（キャッシュ活用、必要な時のみ生成）。
    *   5.3.2. APIコール数やトークン使用量をモニタリングできる仕組みを検討。
5.4. **保守性・拡張性**
    *   5.4.1. 問題生成ロジック、LLM連携部分はモジュール化し、テストしやすくする。
    *   5.4.2. 新しい問題形式やLLMプロバイダーの追加が比較的容易な構造を目指す。
5.5. **エラーハンドリング**
    *   5.5.1. LLM APIエラー、DBエラー、ネットワークエラー等が発生した場合、ユーザーに適切なフィードバック（エラーメッセージ）を表示し、詳細はサーバーログに記録する。
    *   5.5.2. 問題生成に失敗した場合でも、基本的なカード学習（表裏表示）は継続できるフォールバックを提供する。

**6. システム構成要素 (想定)**

*   **フロントエンド:** (例: Next.js, React, Vue.js など)
*   **バックエンド:** Supabase Functions (Edge Functions / Serverless Functions)
*   **データベース:** Supabase PostgreSQL
*   **LLM API:** (例: OpenAI API, Anthropic Claude API など - 具体的なAPIを決定)
*   **バックグラウンドジョブキュー (必要な場合):** Supabaseの機能で不足な場合は外部サービスも検討（例: Inngest, Upstash QStashなど）

**7. 前提・制約事項**

*   認証基盤としてSupabase Authを利用する。
*   データベースは提示されたスキーマ（`cards`テーブル、`questions`テーブル）を基盤とする。
*   使用するLLM APIとその利用規約、料金体系を遵守する。

**8. 用語集**

*   **カード:** 学習対象の情報の単位。表 (Front) と裏 (Back) を持つ。
*   **デッキ:** カードの集まり。
*   **問題形式:** `multiple_choice`, `fill_in_the_blank`, `free_description` など。
*   **問題データ:** LLMによって生成された、特定の形式の問題とその解答などを含むJSONデータ。
*   **キャッシュ:** 一度生成した問題データをDBに保存し、再利用すること。

---

この要件定義書が、開発プロジェクトの明確な指針となることを願っています。
特に、**問題形式の具体的な種類**、**使用するLLM API**、バックグラウンド処理の技術選定など、未定の部分を具体的に決定していくと、より詳細な設計に進めるかと思います。