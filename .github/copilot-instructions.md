# AI 駆動開発 共通ガイドライン

## 開発の基本理念

- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る
- 問題を見つけたら放置せず、必ず対処または明示的に記録する
- ボーイスカウトルール：コードを見つけた時よりも良い状態で残す

## エラーハンドリングの原則

- 関連が薄く見えるエラーでも必ず解決する
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正
- 早期にエラーを検出し、明確なエラーメッセージを提供
- エラーケースも必ずテストでカバーする
- 外部 API やネットワーク通信は必ず失敗する可能性を考慮

## コード品質の基準

- DRY 原則：重複を避け、単一の信頼できる情報源を維持
- 意味のある変数名・関数名で意図を明確に伝える
- プロジェクト全体で一貫したコーディングスタイルを維持
- 小さな問題も放置せず、発見次第修正（Broken Windows 理論）
- コメントは「なぜ」を説明し、「何を」はコードで表現

## コメントとドキュメントの言語規則

- **コード内のコメント**: 英語で記述（グローバルな開発環境での可読性を考慮）
- **ドキュメントファイル**: 日本語で記述（`docs/` 配下のマークダウンファイル、README 等）
- **コミットメッセージ**: 英語で記述（コンベンショナルコミット形式に従う）
- **関数・変数名**: 英語で記述（コードの一貫性のため）
- **エラーメッセージ**: ユーザー向けは日本語、ログやデバッグ用は英語を推奨

## テスト規律

- テストをスキップせず、問題があれば修正する
- 実装詳細ではなく振る舞いをテスト
- テスト間の依存を避け、任意の順序で実行可能に
- テストは高速で、常に同じ結果を返すように
- カバレッジは指標であり、質の高いテストを重視

## 保守性とリファクタリング

- 機能追加と同時に既存コードの改善を検討
- 大規模な変更は小さなステップに分割
- 使用されていないコードは積極的に削除
- 依存関係は定期的に更新（セキュリティと互換性のため）
- 技術的負債は明示的にコメントやドキュメントに記録

## セキュリティの考え方

- API キー、パスワード等は環境変数で管理（ハードコード禁止）
- すべての外部入力を検証
- 必要最小限の権限で動作（最小権限の原則）
- 不要な依存関係を避ける
- セキュリティ監査ツールを定期的に実行

## パフォーマンスの意識

- 推測ではなく計測に基づいて最適化
- 初期段階から拡張性を考慮
- 必要になるまでリソースの読み込みを遅延
- キャッシュの有効期限と無効化戦略を明確に
- N+1 問題やオーバーフェッチを避ける

## 信頼性の確保

- タイムアウト処理を適切に設定
- リトライ機構の実装（指数バックオフを考慮）
- サーキットブレーカーパターンの活用
- 一時的な障害に対する耐性を持たせる
- 適切なログとメトリクスで可観測性を確保

## プロジェクトコンテキストの理解

- ビジネス要件と技術要件のバランスを取る
- 現在のフェーズで本当に必要な品質レベルを判断
- 時間制約がある場合でも、最低限の品質基準を維持
- チーム全体の技術レベルに合わせた実装選択

## トレードオフの認識

- すべてを完璧にすることは不可能（銀の弾丸は存在しない）
- 制約の中で最適なバランスを見つける
- プロトタイプなら簡潔さを、本番なら堅牢性を優先
- 妥協点とその理由を明確にドキュメント化

## Git 運用の基本

- コンベンショナルコミット形式を使用（feat:, fix:, docs:, test:, refactor:, chore:）
- コミットは原子的で、単一の変更に焦点を当てる
- 明確で説明的なコミットメッセージを英語で記述
- main/master ブランチへの直接コミットは避ける

## コードレビューの姿勢

- レビューコメントは建設的な改善提案として受け取る
- 個人ではなくコードに焦点を当てる
- 変更の理由と影響を明確に説明
- フィードバックを学習機会として歓迎

## デバッグのベストプラクティス

- 問題を確実に再現できる手順を確立
- 二分探索で問題の範囲を絞り込む
- 最近の変更から調査を開始
- デバッガー、プロファイラー等の適切なツールを活用
- 調査結果と解決策を記録し、知識を共有

## 依存関係の管理

- 本当に必要な依存関係のみを追加
- package-lock.json 等のロックファイルを必ずコミット
- 新しい依存関係追加前にライセンス、サイズ、メンテナンス状況を確認
- セキュリティパッチとバグ修正のため定期的に更新

## 継続的な改善

- 学んだことを次のプロジェクトに活かす
- 定期的に振り返りを行い、プロセスを改善
- 新しいツールや手法を適切に評価して取り入れる
- チームや将来の開発者のために知識を文書化

## ドキュメント管理

### ドキュメント構造

プロジェクトのドキュメントは `docs/` 配下にソフトウェア開発ライフサイクルに沿って整理されています。

```
docs/
├── README.md                    # ドキュメント全体の説明とナビゲーション
├── 01_planning/                 # 企画・計画
│   ├── ideas/                  # アイデア、発想
│   ├── roadmap/                # ロードマップ
│   └── business/               # ビジネスプラン、料金設定
├── 02_requirements/             # 要件定義
│   └── features/               # 機能別要件定義
├── 03_design/                   # 設計
│   ├── architecture/           # システムアーキテクチャ
│   ├── database/               # DB設計
│   ├── api/                    # API設計
│   ├── features/               # 機能設計
│   └── specifications/         # 技術仕様書
├── 04_implementation/           # 実装
│   ├── plans/                  # 実装計画書
│   └── guides/                 # 実装ガイド
├── 05_testing/                  # テスト
│   └── test-cases/             # テストケース
├── 06_operations/               # 運用
│   ├── deployment/             # デプロイ手順
│   └── maintenance/            # メンテナンス
├── 07_research/                 # 調査・研究
│   └── YYYY_MM/                # 月別整理
├── 08_worklogs/                 # 作業ログ
│   └── YYYY_MM/                # 月別整理
├── 09_improvements/             # 改善提案
├── 10_reverse/                  # リバースエンジニアリング
├── 11_marketing/                # マーケティング
│   └── introductions/          # 製品紹介
├── archive/                     # アーカイブ
│   └── deprecated/             # 廃止機能の資料
└── templates/                   # ドキュメントテンプレート
```

### ドキュメント作成ルール

#### 新規ドキュメントの作成

1. **適切なカテゴリを選択**

   - 企画段階 → `01_planning/`
   - 要件定義 → `02_requirements/features/`
   - 設計 → `03_design/` (architecture/database/api/features/specifications)
   - 実装計画 → `04_implementation/plans/{機能名}/`
   - 調査 → `07_research/YYYY_MM/`
   - 作業ログ → `08_worklogs/YYYY_MM/YYYYMMDD/`
   - 改善提案 → `09_improvements/`

2. **機能別ディレクトリの作成**

   複数のドキュメントが同じ機能に関連する場合、機能別ディレクトリを作成:

   **対象カテゴリ**:

   - `04_implementation/plans/` - 実装計画
   - `08_worklogs/YYYY_MM/YYYYMMDD/` - 日別作業ログ

   **作成ルール**:

   - 機能名でディレクトリを作成（例: `unified-link-mark/`, `pdf-processing/`）
   - ディレクトリ内のファイルは `YYYYMMDD_{番号}_{内容}.md` 形式
   - README.md を作成してディレクトリの概要を記載

   **例**:

   ```
   04_implementation/plans/
   ├── README.md
   └── unified-link-mark/
       ├── 20250925_01_implementation-plan.md
       ├── 20250929_02_p2-implementation-plan.md
       └── 20251011_03_migration-plan.md
   ```

3. **テンプレートを使用**

   - 要件定義: `docs/templates/requirement-template.md`
   - 設計書: `docs/templates/design-template.md`
   - 作業ログ: `docs/templates/worklog-template.md`
   - 調査レポート: `docs/templates/research-template.md`

4. **ファイル命名規則**

   **基本形式**:

   - 日付を含む場合: `YYYYMMDD_{2桁番号}_{説明}.md`
   - 例: `20251012_01_unit-tests-complete.md`, `20251012_02_implementation-status.md`
   - 番号は作業順序を表す（01, 02, 03, ...）
   - 2 桁ゼロパディングで統一（将来の拡張性のため）

   **機能名のみの場合**:

   - 形式: `機能名-タイプ.md` (例: `pdf-processing-design.md`)
   - スネークケースまたはケバブケースを使用

   **共通ルール**:

   - 日本語ファイル名は避ける（検索性・互換性のため）
   - 作業の時系列が明確になり、ドキュメント間の関連性が把握しやすい

#### ドキュメントに含めるべき内容

すべてのドキュメントに以下を含める:

1. **概要**: ドキュメントの目的を明確に
2. **背景**: なぜこのドキュメントが必要か
3. **本文**: 詳細な内容
4. **関連ドキュメント**: 他のドキュメントへのリンク
5. **作成日と最終更新日**: 情報の鮮度を明示

#### 作業ログの記録

日々の作業は必ず `08_worklogs/YYYY_MM/YYYYMMDD/*.md` に記録:

- **作業開始時**: テンプレートを使用して作業ログを作成
- **作業中**: 発見した問題、学び、変更内容を記録
- **作業終了時**: 次回の作業予定、残タスクを明記

**ファイル命名規則**:

- 1 日 1 作業: `YYYYMMDD_説明.md`
- 1 日複数作業: `YYYYMMDD_{2桁番号}_{説明}.md` (例: `20251012_01_unit-tests.md`, `20251012_02_refactoring.md`)
- 番号は作業順序を示す（01, 02, 03, ...）

**記載すべき内容**:

- 実施した作業の詳細
- 変更したファイルと変更内容
- 発見した課題と対応
- 学んだこと・気づき
- テスト結果
- 次回の作業予定

#### 実装計画の記録

実装計画は `04_implementation/plans/{機能名}/` に記録:

- **機能別ディレクトリを作成**: 複数のドキュメントがある場合は必須
- **README.md を配置**: ディレクトリの概要、ファイル一覧、実装の経緯を記載
- **時系列で番号付け**: `YYYYMMDD_{2桁番号}_{内容}.md` 形式で管理
- **関連ドキュメントへのリンク**: 設計書、作業ログへの参照を明記

**ファイル命名例**:

- `20250925_01_implementation-plan.md` - 初期実装計画
- `20250929_02_p2-implementation-plan.md` - Phase 2 計画
- `20251011_07_migration-plan.md` - 移行計画
- `20251011_08_refactoring-plan.md` - リファクタリング計画

#### 調査・研究の記録

技術調査、競合調査は `07_research/YYYY_MM/` に記録:

- **調査前**: 調査目的と背景を明確に
- **調査結果**: 発見したことを構造的に記述
- **メリット・デメリット**: 客観的な評価
- **推奨事項**: 調査結果を踏まえた提案
- **参考資料**: 参照した URL、ドキュメントのリスト

#### ドキュメントの更新

既存ドキュメントを更新する際:

1. **変更履歴を記録**: 何を、なぜ変更したか
2. **最終更新日を更新**: 情報の鮮度を維持
3. **関連ドキュメントも更新**: 一貫性を保つ
4. **古い情報はアーカイブ**: 削除ではなく `archive/` へ移動

#### ドキュメントのアーカイブ

以下の場合はアーカイブへ移動:

- 機能が廃止された
- 情報が古くなり、参照価値がなくなった
- 新しいドキュメントで置き換えられた

**手順**:

1. `archive/deprecated/` または `archive/YYYY_MM/` へ移動
2. ファイル冒頭に廃止理由と日付を追記
3. 新しいドキュメントへのリンクがあれば明記

### AI 開発時のドキュメント活用

#### ドキュメント作成を忘れない

- 新機能の実装前: 要件定義と設計書を作成
- 実装中: 作業ログを記録
- 技術選定時: 調査レポートを作成
- 問題解決後: 解決策をドキュメント化

#### ドキュメントを読んでから実装

- 既存機能の修正前に関連ドキュメントを確認
- 設計意図を理解してから変更を加える
- 過去の作業ログから学ぶ

#### ドキュメントの一貫性

- 複数ドキュメント間の矛盾を発見したら修正
- リンク切れを見つけたら更新
- 情報が古い場合は最新化またはアーカイブ

### ドキュメント検索のコツ

- **目的別**: README.md の「目的別」セクションを参照
- **時系列**: worklogs/ や research/ の月別ディレクトリを確認
- **機能別**: plans/ や worklogs/ 内の機能別ディレクトリを確認
- **日付・番号順**: ファイル名の `YYYYMMDD_{番号}_` でソート・検索
- **機能名**: grep や VS Code の検索機能を活用
- **関連ドキュメント**: 各ドキュメントの「関連ドキュメント」セクションを辿る
