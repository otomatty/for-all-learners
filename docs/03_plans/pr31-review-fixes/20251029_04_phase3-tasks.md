# Phase 3: N+1クエリ最適化 - タスクリスト

**予定実施日**: Phase 2完了後（別PR推奨）  
**ブランチ**: `fix/pr31-review-phase3-n-plus-one` (新規作成予定)  
**所要時間（予定）**: 1-2時間  
**優先度**: 🔴 High（パフォーマンス）

---

## ⚠️ 重要事項

### 別PRでの実施を強く推奨

**理由**:
1. **テスト影響が大きい**: 327件の単体テストの確認が必要
2. **実装が複雑**: バッチクエリとMapロジックの実装
3. **レビュー時間**: 大規模な変更のため丁寧なレビューが必要
4. **リスク管理**: 分離することで問題発生時のロールバックが容易

---

## 📋 事前準備タスク

### 1. 詳細設計書の作成

- [ ] 現在のクエリフローを図解
- [ ] 最適化後のクエリフローを図解
- [ ] 各クエリの役割を文書化
- [ ] データ構造（Map/Set）の設計書作成

### 2. 既存テストの確認

- [ ] 既存の単体テスト（327件）を全て確認
- [ ] テストが何を検証しているか理解
- [ ] 修正後にテストが通るか事前検討

### 3. パフォーマンステスト環境の準備

- [ ] テストデータの準備（10, 20, 50個のリンクグループ）
- [ ] 測定スクリプトの作成
- [ ] Before/After の比較方法の確立

---

## 📋 実装タスク

### Task 1: バッチクエリロジックの実装

**ファイル**: `app/_actions/linkGroups.ts`  
**関数**: `getLinkGroupsForPage`

#### Step 1: IDの収集

```typescript
// 4-1. Collect all target page IDs
const targetPageIds = linkGroupsData
    .map(g => g.page_id)
    .filter((id): id is string => id !== null);

// 4-2. Collect all link group IDs
const linkGroupIds = linkGroupsData.map(g => g.id);
```

- [ ] targetPageIds の収集ロジックを実装
- [ ] linkGroupIds の収集ロジックを実装
- [ ] 型安全性を確保（filter で null を除外）

#### Step 2: バッチフェッチの実装

```typescript
// 4-3. Fetch all target pages in one query
const { data: allTargetPages } = await supabase
    .from("pages")
    .select("id, title, thumbnail_url, content_tiptap, updated_at")
    .in("id", targetPageIds);

// 4-4. Fetch all occurrences in one query
const { data: allOccurrences } = await supabase
    .from("link_occurrences")
    .select("link_group_id, source_page_id")
    .in("link_group_id", linkGroupIds);
```

- [ ] 全ターゲットページを1回のクエリで取得
- [ ] 全オカレンスを1回のクエリで取得
- [ ] エラーハンドリングを追加

#### Step 3: 参照ページIDの収集

```typescript
// 4-5. Collect all referencing page IDs
const allReferencingPageIds = [
    ...new Set(
        (allOccurrences || [])
            .map(o => o.source_page_id)
            .filter(id => id !== pageId && !targetPageIds.includes(id))
    ),
];

// 4-6. Fetch all referencing pages in one query
const { data: allReferencingPages } = await supabase
    .from("pages")
    .select("id, title, thumbnail_url, content_tiptap, updated_at")
    .in("id", allReferencingPageIds)
    .order("updated_at", { ascending: false });
```

- [ ] 参照ページIDの収集（重複除去）
- [ ] 全参照ページを1回のクエリで取得
- [ ] ソート順を保持

---

### Task 2: Mapベースのルックアップロジックの実装

#### Step 1: Mapの構築

```typescript
// 5. Build lookup maps for O(1) access
const targetPagesMap = new Map(
    (allTargetPages || []).map(p => [p.id, p])
);

const occurrencesByGroupId = new Map<string, string[]>();
for (const occ of allOccurrences || []) {
    if (!occurrencesByGroupId.has(occ.link_group_id)) {
        occurrencesByGroupId.set(occ.link_group_id, []);
    }
    occurrencesByGroupId.get(occ.link_group_id)!.push(occ.source_page_id);
}

const referencingPagesMap = new Map(
    (allReferencingPages || []).map(p => [p.id, p])
);
```

- [ ] targetPagesMap の実装
- [ ] occurrencesByGroupId の実装
- [ ] referencingPagesMap の実装
- [ ] 型定義を正確に記述

#### Step 2: 結果の構築

```typescript
// 6. Build result using maps (O(n) instead of O(n²))
const result: LinkGroupForUI[] = linkGroupsData.map(group => {
    // Get target page from map
    const targetPage = group.page_id 
        ? targetPagesMap.get(group.page_id) 
        : null;

    // Get referencing page IDs from map
    const referencingPageIds = (occurrencesByGroupId.get(group.id) || [])
        .filter(id => id !== pageId && id !== group.page_id);

    // Get referencing pages from map
    const referencingPages = referencingPageIds
        .map(id => referencingPagesMap.get(id))
        .filter((p): p is NonNullable<typeof p> => p !== undefined);

    return {
        key: group.key,
        displayText: group.raw_text,
        linkGroupId: group.id,
        pageId: group.page_id,
        linkCount: group.link_count ?? 0,
        targetPage: targetPage ? {
            ...targetPage,
            content_tiptap: targetPage.content_tiptap as Record<string, unknown>,
            updated_at: targetPage.updated_at ?? "",
        } : null,
        referencingPages: referencingPages.map(p => ({
            ...p,
            content_tiptap: p.content_tiptap as Record<string, unknown>,
            updated_at: p.updated_at ?? "",
        })),
    };
});
```

- [ ] Map を使ったルックアップ実装
- [ ] 型安全性の確保
- [ ] 既存の型定義との整合性確認

---

## 🧪 テスト・確認タスク

### 1. 単体テストの確認（327件）

- [ ] 既存の単体テスト全てを実行
- [ ] 失敗するテストがないか確認
- [ ] 失敗する場合、原因を調査・修正

```bash
bun test app/_actions/__tests__/linkGroups.test.ts
```

### 2. 結果の一致確認テスト

- [ ] 最適化前後で結果が同じことを確認するテスト追加

```typescript
describe('getLinkGroupsForPage - optimization', () => {
    it('should return same results as before', async () => {
        // Test with various scenarios
        // - 10 link groups
        // - 20 link groups
        // - 50 link groups
    });
});
```

### 3. エッジケーステスト

- [ ] 空配列のケース
- [ ] page_id が null のケース
- [ ] occurrences が0件のケース
- [ ] リンクグループが1件のケース
- [ ] リンクグループが100件のケース

### 4. パフォーマンステスト

#### 測定項目
- [ ] クエリ実行回数（Before/After）
- [ ] 実行時間（Before/After）
- [ ] メモリ使用量（Before/After）

#### テストケース

| リンクグループ数 | 目標クエリ数 | 目標実行時間 |
|------------------|--------------|--------------|
| 5個 | 4回 | < 100ms |
| 10個 | 4回 | < 150ms |
| 20個 | 4回 | < 200ms |
| 50個 | 4回 | < 300ms |

**測定スクリプト例**:
```typescript
console.time('getLinkGroupsForPage');
const result = await getLinkGroupsForPage(pageId);
console.timeEnd('getLinkGroupsForPage');
console.log('Total queries:', queryCount);
```

---

## 📊 完了基準

### 必須条件
- [ ] バッチクエリ実装完了
- [ ] Map ベースのルックアップ実装完了
- [ ] 既存の単体テスト（327件）全てパス
- [ ] 結果の一致確認テスト追加・パス
- [ ] エッジケーステスト全てパス
- [ ] `bun lint` がエラーなし
- [ ] `bun test` が全てパス

### 推奨条件
- [ ] パフォーマンステスト実施
- [ ] Before/After の測定結果を記録
- [ ] クエリ数が75%以上削減
- [ ] 実行時間が5倍以上改善

---

## 📊 期待される改善効果

### クエリ数の削減

| リンクグループ数 | Before | After | 削減率 |
|------------------|--------|-------|--------|
| 5個 | 15-20回 | 4回 | 75-80% |
| 10個 | 30-40回 | 4回 | 87-90% |
| 20個 | 60-80回 | 4回 | 93-95% |
| 50個 | 150-200回 | 4回 | 97-98% |

### パフォーマンス改善

- ページ表示時間: 500-1000ms → 50-100ms（**10倍高速化**）
- データベース負荷: **75-90%削減**
- スケーラビリティ: リンクグループ数に関わらず安定

---

## 🚀 PR作成

### PR タイトル
```
perf: Optimize N+1 query issue in getLinkGroupsForPage
```

### PR 説明テンプレート
```markdown
## 概要
`getLinkGroupsForPage` 関数のN+1クエリ問題を修正し、パフォーマンスを大幅に改善しました。

## 変更内容
- ループ内の個別クエリをバッチクエリに変更
- Map を使ったO(1)ルックアップを実装
- クエリ数を4回に固定（リンクグループ数に関わらず）

## パフォーマンス改善
- クエリ数: 30-40回 → 4回（87-90%削減）
- 実行時間: 500-1000ms → 50-100ms（10倍高速化）
- データベース負荷: 75-90%削減

## テスト
- 既存の単体テスト（327件）全てパス
- 結果の一致を確認する統合テスト追加
- パフォーマンステスト実施（Before/After測定）

## 関連
- Addresses Gemini Code Assist review comment in PR#31
- Related to: #31
```

---

## 🔗 関連ドキュメント

- **実装計画**: `docs/03_plans/pr31-review-fixes/20251029_01_implementation-plan.md`
- **Phase 1**: `docs/03_plans/pr31-review-fixes/20251029_02_phase1-tasks.md`
- **Phase 2**: `docs/03_plans/pr31-review-fixes/20251029_03_phase2-tasks.md`
- **既存テスト**: `app/_actions/__tests__/linkGroups.test.ts`

---

**最終更新**: 2025-10-29  
**ステータス**: 準備中（Phase 1, 2完了後に実施）⏳
