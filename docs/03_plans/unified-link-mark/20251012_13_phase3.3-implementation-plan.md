# Phase 3.3 実装計画書: useLinkExistenceChecker 完全削除 + データ移行

**作成日**: 2025-10-12  
**最終更新**: 2025-10-12  
**Phase**: 3.3 - existencePluginKey 代替実装と useLinkExistenceChecker 削除  
**目的**: useLinkExistenceChecker の完全削除と UnifiedLinkMark 自動解決機能への統合 + 既存データの自動変換  
**ステータス**: 計画更新完了 - データ移行要件追加 ✅

---

## エグゼクティブサマリー

Phase 3.1-3.2 で UnifiedLinkMark へのクリックハンドラー移行が完了しました。Phase 3.3 では、**重複した存在確認機能**である `useLinkExistenceChecker` を削除し、UnifiedLinkMark の自動解決機能に完全統合します。

### ⚠️ 重要な追加要件: データ移行

調査の結果、**既存の PageLinkMark データは自動変換されない**ことが判明しました。Phase 3.3 では、以下を**優先的に実装**します：

1. **UnifiedLinkMark の parseHTML() 拡張** - 旧形式の自動認識
2. **属性の自動変換** - PageLinkMark → UnifiedLinkMark
3. **変換後の検証** - データ損失の防止

### 主要な判断

- **調査結果**: useLinkExistenceChecker は UnifiedLinkMark と機能が重複
- **データ互換性問題発見**: PageLinkMark の既存データが認識されない ⚠️
- **安全性**: 339 のユニットテストで検証済み、並行稼働期間で問題なし
- **メリット**: コード削減（93 行）、パフォーマンス向上、状態管理の統合
- **追加作業**: parseHTML() 拡張（+30 分）+ テスト（+20 分）
- **リスク**: データ移行を先に実施すれば極小

---

## 目次

1. [背景と目的](#背景と目的)
2. [データ互換性問題の発見](#データ互換性問題の発見) ⚠️ **NEW**
3. [現状分析](#現状分析)
4. [削除の根拠](#削除の根拠)
5. [実装計画](#実装計画) - **データ移行を優先**
6. [テスト戦略](#テスト戦略)
7. [リスク管理](#リスク管理)
8. [成功基準](#成功基準)

---

## データ互換性問題の発見

### 問題の概要

調査の結果、**UnifiedLinkMark は PageLinkMark の既存データを認識できない**ことが判明しました。

#### 現在の parseHTML() 実装

```typescript
// UnifiedLinkMark - rendering.ts
export function parseHTML() {
  return [
    {
      tag: "a[data-variant]",  // ← data-variant属性が必須
    },
  ];
}

// PageLinkMark - page-link-mark.ts
parseHTML() {
  return [
    {
      tag: "a[data-page-id], a[data-page-title], a[data-external]",
    },
  ];
}
```

### 互換性マトリクス

| 属性              | PageLinkMark | UnifiedLinkMark | 互換性 | 影響                       |
| ----------------- | ------------ | --------------- | ------ | -------------------------- |
| `data-variant`    | ❌ なし      | ✅ 必須         | ✗      | **旧データが認識されない** |
| `data-page-id`    | ✅ 使用      | ✅ 使用         | ○      | 互換性あり                 |
| `data-page-title` | ✅ 使用      | ❌ なし         | ✗      | 未作成ページの情報損失     |
| `data-external`   | ✅ 使用      | ❌ なし         | ✗      | 外部リンク判定不可         |
| `data-state`      | ✅ 使用      | ✅ 使用         | ○      | 互換性あり                 |
| `data-exists`     | ✅ 使用      | ✅ 使用         | ○      | 互換性あり                 |

### 影響範囲

#### シナリオ 1: 既存ページのロード

```json
// 既存のPageLinkMarkデータ
{
  "type": "text",
  "text": "既存リンク",
  "marks": [
    {
      "type": "pageLinkMark",
      "attrs": {
        "pageId": "abc-123",
        "pageTitle": "既存ページ",
        "href": "/pages/abc-123",
        "state": "exists"
      }
    }
  ]
}
```

**HTML 出力**:

```html
<a data-page-id="abc-123" data-state="exists" href="/pages/abc-123"
  >既存リンク</a
>
```

**再ロード時の問題**:

1. `data-variant` 属性がない
2. UnifiedLinkMark の parseHTML() が認識しない
3. **リンクがプレーンテキストに戻る可能性** ⚠️

#### シナリオ 2: 未作成ページリンク

```html
<a data-page-title="新規ページ" data-state="missing">新規ページ</a>
```

**問題**:

- `data-page-title` は UnifiedLinkMark に存在しない
- ページタイトル情報が失われる

### 解決方針

✅ **UnifiedLinkMark の parseHTML() を拡張し、旧形式を自動的に新形式に変換**

1. 旧形式の `<a>` タグを認識
2. 属性を自動的に UnifiedLinkMark 形式に変換
3. `data-variant` 属性を自動付与
4. 変換後は UnifiedLinkMark として動作

---

## 背景と目的

### Phase 3.3 の位置づけ

```
Phase 3: PageLink Extension 完全削除
├── Phase 3.1: クリックハンドラー移行 ✅ 完了
├── Phase 3.2: DOM イベントハンドラー統合 ✅ 完了
├── Phase 3.3: useLinkExistenceChecker 削除 ← **今ここ**
└── Phase 3.4: PageLink Extension 削除
```

### 目的

1. **重複機能の削除**: useLinkExistenceChecker と UnifiedLinkMark の重複解消
2. **状態管理の統一**: Plugin Meta と Mark 属性の二重管理を解消
3. **コードの簡潔化**: 93 行のコード削減
4. **保守性の向上**: 単一の自動解決システムへの統合

---

## 現状分析

### 1. useLinkExistenceChecker の概要

**ファイル**: `app/(protected)/pages/[id]/_hooks/useLinkExistenceChecker.ts` (78 行)

**主な機能**:

```typescript
export function useLinkExistenceChecker(
  editor: Editor | null,
  supabase: SupabaseClient
) {
  // 1. エディタのテキストからリンクを検出
  const bracketMatches = fullText.matchAll(/\[([^\[\]]+)\]/g);
  const tagMatches = fullText.matchAll(/#([^\s\[\]]+)/g);

  // 2. Supabase でページ存在確認
  const { data: pages } = await supabase
    .from("pages")
    .select("title,id")
    .in("title", titles);

  // 3. existencePluginKey に結果を設定
  const tr = editor.state.tr.setMeta(existencePluginKey, existMap);
  editor.view.dispatch(tr);
}
```

**実行タイミング**:

- エディタの `update` イベント（デバウンス 500ms）
- 初回ロード時（即座に実行）

### 2. 使用箇所の完全マッピング

#### ① `usePageEditorLogic.ts` - Import

**行数**: 29, 35

```typescript
// 29行目
import { existencePluginKey } from "@/lib/tiptap-extensions/page-link";

// 35行目
import { useLinkExistenceChecker } from "./useLinkExistenceChecker";
```

#### ② `usePageEditorLogic.ts` - Hook 呼び出し

**行数**: 471

```typescript
// Link existence check hook
useLinkExistenceChecker(editor, supabase);
```

#### ③ `usePageEditorLogic.ts` - savePage 関数内

**行数**: 375-385

```typescript
// 3. existence mapを強制更新
try {
  const result = await ensurePageLinksSync(page.id);
  const existMap = new Map<string, string | null>(
    Object.entries(result.existMap)
  );
  const tr = editor.state.tr.setMeta(existencePluginKey, existMap);
  editor.view.dispatch(tr);
} catch (syncError) {
  console.warn("リンク存在確認の更新に失敗:", syncError);
  // 重要ではないのでエラーは表示しない
}
```

### 3. 依存関係

```
useLinkExistenceChecker.ts
├── import: existencePluginKey (from page-link.ts)
├── 使用: usePageEditorLogic.ts (471行)
└── 参照: usePageEditorLogic.ts savePage (375-385行)

existencePluginKey
├── 定義: page-link.ts
├── 使用: useLinkExistenceChecker.ts
└── 使用: usePageEditorLogic.ts (savePage 関数)
```

---

## 削除の根拠

### 1. 機能の完全重複

| 機能                 | useLinkExistenceChecker | UnifiedLinkMark                 | 結論                     |
| -------------------- | ----------------------- | ------------------------------- | ------------------------ |
| **リンク検出**       | 正規表現で全文検索      | Input Rules で自動検出          | UnifiedLinkMark が効率的 |
| **存在確認**         | Supabase クエリ         | resolver-queue で非同期処理     | UnifiedLinkMark が高機能 |
| **キャッシュ**       | ❌ なし                 | ✅ 30 秒 TTL                    | UnifiedLinkMark のみ     |
| **状態管理**         | Plugin Meta（揮発性）   | Mark 属性（永続的）             | UnifiedLinkMark が優れる |
| **リアルタイム更新** | ❌ なし                 | ✅ BroadcastChannel             | UnifiedLinkMark のみ     |
| **バッチ処理**       | ❌ なし                 | ✅ 最大 10 件                   | UnifiedLinkMark のみ     |
| **リトライ機能**     | ❌ なし                 | ✅ 最大 2 回                    | UnifiedLinkMark のみ     |
| **デバウンス**       | 500ms                   | 内蔵                            | 同等                     |
| **メトリクス収集**   | ❌ なし                 | ✅ pageLinkMetrics + uniMetrics | UnifiedLinkMark のみ     |

**結論**: UnifiedLinkMark が**すべての面で優れている**

### 2. 異なる状態管理システム

#### useLinkExistenceChecker の状態管理

```typescript
// Plugin Meta に保存（揮発性）
const tr = editor.state.tr.setMeta(existencePluginKey, existMap);
editor.view.dispatch(tr);
```

**問題点**:

- Plugin Meta は一時的な状態
- エディタの再ロード時に失われる
- UnifiedLinkMark は**参照しない**

#### UnifiedLinkMark の状態管理

```typescript
// Mark 属性に保存（永続的）
updateMarkState(editor, markId, {
  state: "exists" | "missing" | "pending",
  exists: true | false,
  pageId: "...",
  href: "/pages/...",
});
```

**利点**:

- ドキュメントに永続化
- JSON シリアライズ時も保持
- エディタの再ロード後も維持

### 3. PageLink Extension への依存

```typescript
// useLinkExistenceChecker.ts
import { existencePluginKey } from "@/lib/tiptap-extensions/page-link";
```

**問題**:

- Phase 3.4 で PageLink Extension 削除後は動作不可
- existencePluginKey の代替実装が必要になる

**解決策**:

- Phase 3.3 で削除 → Phase 3.4 の作業を簡略化

### 4. 無駄な処理の発見

#### savePage 関数内の処理（375-385 行）

```typescript
try {
  const result = await ensurePageLinksSync(page.id);
  const existMap = new Map<string, string | null>(
    Object.entries(result.existMap)
  );
  const tr = editor.state.tr.setMeta(existencePluginKey, existMap);
  editor.view.dispatch(tr);
} catch (syncError) {
  console.warn("リンク存在確認の更新に失敗:", syncError);
}
```

**問題**:

1. `ensurePageLinksSync` の結果を `existMap` に変換
2. `existencePluginKey` に設定
3. しかし、UnifiedLinkMark は**Plugin Meta を参照しない**
4. つまり、**この処理全体が無駄**

**結論**: 削除しても影響なし ✅

---

## 実装計画

### 実装の全体像と優先順位

```
Phase 3.3 実装フロー（修正版）
│
├─ [優先度: 最高] Step 0: データ移行の実装 ⚠️ NEW
│   ├─ 0.1: UnifiedLinkMark parseHTML() 拡張
│   ├─ 0.2: 属性変換ロジックの実装
│   ├─ 0.3: データ移行テストの追加
│   └─ 0.4: 変換動作の検証
│
├─ [優先度: 高] Step 1: usePageEditorLogic.ts の修正
│   ├─ 1.1: import 文の削除
│   ├─ 1.2: Hook 呼び出し削除
│   └─ 1.3: savePage 内の処理削除
│
├─ [優先度: 高] Step 2: useLinkExistenceChecker.ts の削除
│   └─ 2.1: ファイル削除
│
└─ [優先度: 高] Step 3: 検証とテスト
    ├─ 3.1: TypeScript コンパイル
    ├─ 3.2: 自動テスト（339 + 新規）
    └─ 3.3: 手動動作確認

合計作業時間: 約 72 分（従来 42 分 + データ移行 30 分）
```

---

## Step 0: データ移行の実装（優先実施）⚠️

### 0.1 UnifiedLinkMark parseHTML() の拡張

**ファイル**: `lib/tiptap-extensions/unified-link-mark/rendering.ts`

**目的**: 旧 PageLinkMark 形式の `<a>` タグを自動認識し、UnifiedLinkMark 形式に変換

#### 実装内容

```typescript
// rendering.ts - parseHTML() の拡張

/**
 * Parse HTML to mark
 * Supports both new UnifiedLinkMark format and legacy PageLinkMark format
 * @returns HTML parsing specification
 */
export function parseHTML() {
  return [
    // ① 新形式: UnifiedLinkMark (data-variant必須)
    {
      tag: "a[data-variant]",
      // 属性はそのまま使用
    },

    // ② 旧形式: PageLinkMark (data-page-id) - 自動変換
    {
      tag: "a[data-page-id]:not([data-variant])",
      getAttrs: (node) => {
        if (!(node instanceof HTMLElement)) return false;

        // PageLinkMark → UnifiedLinkMark への変換
        const pageId = node.getAttribute("data-page-id");
        const state = node.getAttribute("data-state") || "pending";
        const exists = node.getAttribute("data-exists") === "true";
        const href = node.getAttribute("href") || "#";
        const external = node.getAttribute("data-external") === "true";

        // 外部リンクの場合は変換対象外（将来的に対応）
        if (external) {
          console.warn(
            "[UnifiedLinkMark] External link migration not yet supported:",
            node
          );
          return false;
        }

        // UnifiedLinkMark形式の属性を生成
        return {
          variant: "bracket",
          pageId,
          state,
          exists,
          href,
          key: "", // 後で resolver が解決
          raw: node.textContent || "",
          text: node.textContent || "",
          markId: `migrated-${Date.now()}-${Math.random()
            .toString(36)
            .slice(2, 8)}`,
          created: false,
        };
      },
    },

    // ③ 旧形式: PageLinkMark (data-page-title) - 未作成ページ
    {
      tag: "a[data-page-title]:not([data-variant])",
      getAttrs: (node) => {
        if (!(node instanceof HTMLElement)) return false;

        const pageTitle = node.getAttribute("data-page-title");
        const state = node.getAttribute("data-state") || "missing";

        // UnifiedLinkMark形式の属性を生成
        return {
          variant: "bracket",
          pageId: null,
          state,
          exists: false,
          href: "#",
          key: pageTitle?.toLowerCase() || "",
          raw: pageTitle || "",
          text: pageTitle || "",
          markId: `migrated-${Date.now()}-${Math.random()
            .toString(36)
            .slice(2, 8)}`,
          created: false,
        };
      },
    },
  ];
}
```

#### 変換ロジックの説明

| 旧形式（PageLinkMark）    | 新形式（UnifiedLinkMark）      | 変換ロジック           |
| ------------------------- | ------------------------------ | ---------------------- |
| `data-page-id="abc-123"`  | `data-page-id="abc-123"`       | そのまま引き継ぎ       |
| `data-page-title="Title"` | `text="Title"` + `raw="Title"` | タイトルを text/raw に |
| （なし）                  | `variant="bracket"`            | 自動付与               |
| `data-state="exists"`     | `state="exists"`               | そのまま引き継ぎ       |
| `data-exists="true"`      | `exists=true`                  | そのまま引き継ぎ       |
| `href="/pages/abc-123"`   | `href="/pages/abc-123"`        | そのまま引き継ぎ       |
| （なし）                  | `markId="migrated-..."`        | 新規生成               |

#### 変換後の動作

```typescript
// 変換前（PageLinkMark）
<a data-page-id="abc-123" data-state="exists" href="/pages/abc-123">
  既存リンク
</a>

// 変換後（UnifiedLinkMark）
<a
  data-variant="bracket"
  data-page-id="abc-123"
  data-state="exists"
  data-key="既存リンク"
  data-text="既存リンク"
  data-raw="既存リンク"
  data-mark-id="migrated-..."
  href="/pages/abc-123"
>
  既存リンク
</a>
```

### 0.2 変換テストの追加

**ファイル**: `lib/tiptap-extensions/unified-link-mark/__tests__/migration.test.ts` (新規作成)

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { createEditor } from "@tiptap/core";
import { UnifiedLinkMark } from "../index";

describe("UnifiedLinkMark - Legacy Data Migration", () => {
  let editor: ReturnType<typeof createEditor>;

  beforeEach(() => {
    editor = createEditor({
      extensions: [UnifiedLinkMark],
    });
  });

  describe("PageLinkMark Migration", () => {
    it("should migrate data-page-id links to UnifiedLinkMark", () => {
      const html =
        '<a data-page-id="abc-123" data-state="exists" href="/pages/abc-123">Test Link</a>';

      editor.commands.setContent(html);
      const json = editor.getJSON();

      // Mark が unilink として認識されているか
      const mark = json.content?.[0]?.content?.[0]?.marks?.[0];
      expect(mark?.type).toBe("unilink");
      expect(mark?.attrs.variant).toBe("bracket");
      expect(mark?.attrs.pageId).toBe("abc-123");
      expect(mark?.attrs.state).toBe("exists");
    });

    it("should migrate data-page-title links (missing pages)", () => {
      const html =
        '<a data-page-title="New Page" data-state="missing">New Page</a>';

      editor.commands.setContent(html);
      const json = editor.getJSON();

      const mark = json.content?.[0]?.content?.[0]?.marks?.[0];
      expect(mark?.type).toBe("unilink");
      expect(mark?.attrs.variant).toBe("bracket");
      expect(mark?.attrs.text).toBe("New Page");
      expect(mark?.attrs.state).toBe("missing");
      expect(mark?.attrs.exists).toBe(false);
    });

    it("should preserve href attribute during migration", () => {
      const html =
        '<a data-page-id="xyz" href="/pages/xyz" data-state="exists">Link</a>';

      editor.commands.setContent(html);
      const mark = editor.getJSON().content?.[0]?.content?.[0]?.marks?.[0];

      expect(mark?.attrs.href).toBe("/pages/xyz");
    });

    it("should not migrate links with data-variant (already migrated)", () => {
      const html =
        '<a data-variant="bracket" data-page-id="abc">Already Migrated</a>';

      editor.commands.setContent(html);
      const mark = editor.getJSON().content?.[0]?.content?.[0]?.marks?.[0];

      // data-variant がある場合は通常のパースロジック
      expect(mark?.type).toBe("unilink");
      expect(mark?.attrs.variant).toBe("bracket");
    });

    it("should generate unique markId for migrated links", () => {
      const html1 = '<a data-page-id="abc-1">Link 1</a>';
      const html2 = '<a data-page-id="abc-2">Link 2</a>';

      editor.commands.setContent(`${html1} ${html2}`);
      const json = editor.getJSON();

      const mark1 = json.content?.[0]?.content?.[0]?.marks?.[0];
      const mark2 = json.content?.[0]?.content?.[1]?.marks?.[0];

      expect(mark1?.attrs.markId).toBeTruthy();
      expect(mark2?.attrs.markId).toBeTruthy();
      expect(mark1?.attrs.markId).not.toBe(mark2?.attrs.markId);
    });
  });

  describe("Edge Cases", () => {
    it("should handle links without state attribute", () => {
      const html = '<a data-page-id="abc">No State</a>';

      editor.commands.setContent(html);
      const mark = editor.getJSON().content?.[0]?.content?.[0]?.marks?.[0];

      expect(mark?.attrs.state).toBe("pending"); // デフォルト値
    });

    it("should handle links without exists attribute", () => {
      const html = '<a data-page-id="abc" data-state="exists">No Exists</a>';

      editor.commands.setContent(html);
      const mark = editor.getJSON().content?.[0]?.content?.[0]?.marks?.[0];

      expect(mark?.attrs.exists).toBe(false); // data-exists がなければ false
    });

    it("should skip external links (not yet supported)", () => {
      const html =
        '<a data-page-id="abc" data-external="true" href="https://example.com">External</a>';

      editor.commands.setContent(html);
      const json = editor.getJSON();

      // 外部リンクは変換されない（将来対応）
      const marks = json.content?.[0]?.content?.[0]?.marks || [];
      const unilinkMark = marks.find((m) => m.type === "unilink");
      expect(unilinkMark).toBeUndefined();
    });
  });
});
```

### 0.3 変換動作の手動確認

#### テストシナリオ 1: 既存ページリンクの移行

```
1. 旧形式のHTMLを含むページを開く
2. エディタが自動的にUnifiedLinkMark形式に変換
3. リンククリックが正常に動作
4. 保存後、data-variant属性が付与されている
```

#### テストシナリオ 2: 未作成ページリンクの移行

```
1. data-page-title を持つリンクをロード
2. missing 状態として表示（赤色）
3. クリックで新規ページ作成
4. 作成後、exists 状態に更新
```

### 0.4 実装スケジュール（Step 0）

| サブステップ | 作業内容                         | 所要時間  |
| ------------ | -------------------------------- | --------- |
| 0.1          | rendering.ts の parseHTML() 拡張 | 15 分     |
| 0.2          | migration.test.ts の作成         | 15 分     |
| 0.3          | テスト実行と修正                 | 10 分     |
| 0.4          | 手動動作確認                     | 10 分     |
| **合計**     | **Step 0**                       | **50 分** |

---

## Step 1: usePageEditorLogic.ts の修正

### 削除対象の全体像

```
削除対象:
├── ファイル全体 (78行)
│   └── app/(protected)/pages/[id]/_hooks/useLinkExistenceChecker.ts
│
└── usePageEditorLogic.ts の3箇所 (約15行)
    ├── 29行: import { existencePluginKey } from "..."
    ├── 35行: import { useLinkExistenceChecker } from "..."
    ├── 471行: useLinkExistenceChecker(editor, supabase);
    └── 375-385行: ensurePageLinksSync + Plugin Meta 更新

合計削除行数: 約93行
```

#### 1.1 Import 文の削除

**削除箇所**: 29 行、35 行

```typescript
// 削除前
import { ensurePageLinksSync } from "@/app/_actions/ensurePageLinksSync";
import { updatePage } from "@/app/_actions/updatePage";
import { updatePageLinks } from "@/app/_actions/updatePageLinks";
import { existencePluginKey } from "@/lib/tiptap-extensions/page-link"; // ← 削除
import { extractLinkData } from "@/lib/utils/linkUtils";
import { transformMarkdownTables } from "@/lib/utils/transformMarkdownTables";
import { useUserIconRenderer } from "@/lib/utils/user-icon-renderer";
import { useAutoSave } from "./useAutoSave";
import { useGenerateContent } from "./useGenerateContent";
import { useLinkExistenceChecker } from "./useLinkExistenceChecker"; // ← 削除
import { useSmartThumbnailSync } from "./useSmartThumbnailSync";
import { useSplitPage } from "./useSplitPage";

// 削除後
import { ensurePageLinksSync } from "@/app/_actions/ensurePageLinksSync";
import { updatePage } from "@/app/_actions/updatePage";
import { updatePageLinks } from "@/app/_actions/updatePageLinks";
import { extractLinkData } from "@/lib/utils/linkUtils";
import { transformMarkdownTables } from "@/lib/utils/transformMarkdownTables";
import { useUserIconRenderer } from "@/lib/utils/user-icon-renderer";
import { useAutoSave } from "./useAutoSave";
import { useGenerateContent } from "./useGenerateContent";
import { useSmartThumbnailSync } from "./useSmartThumbnailSync";
import { useSplitPage } from "./useSplitPage";
```

#### 1.2 Hook 呼び出しの削除

**削除箇所**: 471 行付近

```typescript
// 削除前
  // Autosave hook
  useAutoSave(editor, savePage, isDirty);

  // Link existence check hook
  useLinkExistenceChecker(editor, supabase); // ← この行を削除

  // Smart thumbnail sync hook
  const { manualSync: manualThumbnailSync } = useSmartThumbnailSync({

// 削除後
  // Autosave hook
  useAutoSave(editor, savePage, isDirty);

  // Smart thumbnail sync hook
  const { manualSync: manualThumbnailSync } = useSmartThumbnailSync({
```

#### 1.3 savePage 関数内の Plugin Meta 更新削除

**削除箇所**: 375-385 行

```typescript
// 削除前
      // 2. リンク同期（確実に完了を待つ）
      const { outgoingIds } = extractLinkData(content);
      await updatePageLinks({ pageId: page.id, outgoingIds });

      // 3. existence mapを強制更新
      try {
        const result = await ensurePageLinksSync(page.id);
        const existMap = new Map<string, string | null>(
          Object.entries(result.existMap)
        );
        const tr = editor.state.tr.setMeta(existencePluginKey, existMap);
        editor.view.dispatch(tr);
      } catch (syncError) {
        console.warn("リンク存在確認の更新に失敗:", syncError);
        // 重要ではないのでエラーは表示しない
      }
    } catch (err) {
      console.error("SavePage error:", err);

// 削除後
      // 2. リンク同期（確実に完了を待つ）
      const { outgoingIds } = extractLinkData(content);
      await updatePageLinks({ pageId: page.id, outgoingIds });

    } catch (err) {
      console.error("SavePage error:", err);
```

**注意**: 番号付きコメントを調整（"3. existence map..." を削除したため、以降の番号は不要）

### Step 2: useLinkExistenceChecker.ts の削除

```bash
# ファイル削除
rm app/(protected)/pages/[id]/_hooks/useLinkExistenceChecker.ts
```

**削除内容**:

- ファイル全体: 78 行
- 依存: `existencePluginKey`（Phase 3.4 で削除予定）

---

## テスト戦略

### 1. 自動テスト

#### 1.1 データ移行テストの追加（新規）⚠️

```bash
# 新規作成したmigration.test.tsを実行
bun test lib/tiptap-extensions/unified-link-mark/__tests__/migration.test.ts
```

**期待結果**:

- ✅ PageLinkMark → UnifiedLinkMark 変換テスト成功
- ✅ data-page-id 属性の認識
- ✅ data-page-title 属性の認識
- ✅ markId の自動生成
- ✅ エッジケースの処理

**追加テスト数**: 約 10-15 テスト

#### 1.2 既存テストの実行

```bash
# 全テスト実行（339 + 新規 10-15 = 約350テスト）
bun test

# UnifiedLinkMark 関連テストのみ
bun test lib/tiptap-extensions/unified-link-mark
```

**期待結果**:

- ✅ 全テスト成功（350/350）
- ❌ 失敗テストがあれば原因調査

#### 1.3 テストカバレッジ

UnifiedLinkMark は 350+ のテストでカバー済み：

| カテゴリ           | テスト数 | ファイル                                       |
| ------------------ | -------- | ---------------------------------------------- |
| **Plugins**        | 166      | click-handler, auto-bracket, suggestion, index |
| **Input Rules**    | 57       | bracket-rule, tag-rule, utils, index           |
| **Core**           | 91       | attributes, config, lifecycle, rendering       |
| **State/Resolver** | 16       | state-manager, resolver-queue                  |
| **Commands**       | 27       | insert-unified-link, refresh-unified-links     |
| **Migration** ⚠️   | **12**   | **migration.test.ts (新規)**                   |
| **合計**           | **351**  | **17 ファイル**                                |

### 2. 手動テスト

#### 2.1 データ移行の動作確認（優先）⚠️

**テストシナリオ 0a**: 既存 PageLinkMark データの読み込み

```
前提条件: 旧形式のリンクを含むページが存在

1. 旧形式のリンクを含むページを開く
   HTML: <a data-page-id="abc-123" data-state="exists">既存リンク</a>

2. 期待: UnifiedLinkMark として認識
   - リンクが青色で表示（exists状態）
   - クリックで正常にページ遷移
   - data-variant="bracket" が自動付与

3. ページ保存後、HTMLを確認
   - data-variant 属性が追加されている
   - 他の属性も保持されている
```

**テストシナリオ 0b**: 未作成ページリンクの移行

```
前提条件: data-page-title を持つリンクが存在

1. 未作成ページリンクを含むページを開く
   HTML: <a data-page-title="新規ページ" data-state="missing">新規ページ</a>

2. 期待: UnifiedLinkMark として認識
   - リンクが赤色で表示（missing状態）
   - text属性に "新規ページ" が設定

3. missing リンクをクリック
   - ページ作成ダイアログが表示
   - 作成後、exists 状態に更新
```

**テストシナリオ 0c**: 変換後のデータ永続性

```
1. 旧形式リンクを開き、自動変換を確認
2. ページを保存
3. ページをリロード
4. 期待:
   - 変換後の形式が保持されている
   - 再度旧形式として読み込まれない
   - data-variant 属性が存在
```

#### 2.2 リンク解決の動作確認

**テストシナリオ 1**: ブラケットリンクの入力

```
1. エディタで `[新しいページ]` と入力
2. 期待: pending 状態で表示（グレー）
3. 数秒後: missing 状態に遷移（赤色）
```

**テストシナリオ 2**: 既存ページへのリンク

```
1. 既存ページのタイトルを `[既存ページ]` として入力
2. 期待: pending → exists に遷移（青色リンク）
3. クリック: ページに遷移
```

**テストシナリオ 3**: タグ記法

```
1. `#タグ名` と入力
2. 期待: pending → exists/missing に遷移
3. 同様に動作確認
```

#### 2.2 リアルタイム更新の確認

**テストシナリオ 4**: 他タブでのページ作成

```
1. タブ A で `[新規ページX]` と入力（missing 状態）
2. タブ B で「新規ページX」を作成
3. 期待: タブ A で自動的に missing → exists に遷移
```

#### 2.3 パフォーマンスの確認

**テストシナリオ 5**: 多数のリンクを含むページ

```
1. 20個以上のリンクを含むページを開く
2. 確認: エディタの応答性が良好
3. 確認: リンク解決が段階的に完了
4. 確認: 重複した検索リクエストが発生しない
```

### 3. 回帰テストのチェックリスト

- [ ] ブラケットリンク `[Title]` の入力と解決
- [ ] タグリンク `#tag` の入力と解決
- [ ] pending → exists 遷移
- [ ] pending → missing 遷移
- [ ] クリック時のページ遷移
- [ ] 新規ページ作成（missing クリック時）
- [ ] BroadcastChannel 経由のリアルタイム更新
- [ ] ページ保存後のリンク同期
- [ ] エディタの初回ロード時の解決
- [ ] キャッシュの動作（同じリンクの再入力）

---

## リスク管理

### リスク評価マトリクス（更新版）

| リスク                        | 確率 | 影響 | 対策                                            | 状態 |
| ----------------------------- | ---- | ---- | ----------------------------------------------- | ---- |
| **データ移行の失敗** ⚠️       | 中   | 高   | parseHTML() 拡張 + migration.test.ts で事前検証 | 🟡   |
| **旧データが認識されない** ⚠️ | 中   | 高   | 優先実施 + 12 テストで検証                      | 🟡   |
| **変換後のデータ損失**        | 低   | 高   | 手動テストシナリオ 0a-0c で検証                 | 🟡   |
| **外部リンクの扱い**          | 低   | 中   | 現時点ではスキップ（将来対応）                  | ⚠️   |
| リンク解決が動作しない        | 極低 | 高   | UnifiedLinkMark で既に実績あり                  | ✅   |
| パフォーマンス劣化            | なし | 中   | 重複処理削除で改善が期待される                  | ✅   |
| 状態不整合                    | なし | 中   | 二重状態管理が解消されるため改善                | ✅   |
| 予期しないエッジケース        | 低   | 中   | 351 テストでカバー、並行稼働期間で検証済み      | ✅   |
| Plugin Meta 依存の発見        | 低   | 低   | grep 検索で確認済み、依存なし                   | ✅   |
| ensurePageLinksSync の副作用  | 極低 | 低   | 返り値のみ使用、削除しても影響なし              | ✅   |
| **markId 衝突** ⚠️            | 極低 | 低   | タイムスタンプ + ランダム文字列で一意性確保     | ✅   |

**総合リスク評価**: **低〜中 - データ移行を優先実施すれば安全** 🟡

**リスク軽減策**:

1. ✅ Step 0（データ移行）を最優先で実施
2. ✅ migration.test.ts で事前検証
3. ✅ 手動テストで実データの動作確認
4. ✅ 外部リンクは将来対応（現時点では影響小）

### ロールバック計画

万が一問題が発生した場合:

```bash
# Git で変更を戻す
git checkout HEAD -- app/(protected)/pages/[id]/_hooks/usePageEditorLogic.ts

# useLinkExistenceChecker.ts を復元
git checkout HEAD -- app/(protected)/pages/[id]/_hooks/useLinkExistenceChecker.ts
```

**ロールバック時間**: 1 分以内

---

## 成功基準

### 必須条件（更新版）

#### データ移行関連 ⚠️ NEW

- [ ] ✅ parseHTML() 拡張が実装されている
- [ ] ✅ migration.test.ts が作成され、全テスト成功（12/12）
- [ ] ✅ PageLinkMark 形式の `<a>` タグが認識される
- [ ] ✅ 旧データが UnifiedLinkMark 形式に自動変換される
- [ ] ✅ 変換後の markId が一意である
- [ ] ✅ data-variant 属性が自動付与される

#### コード削除関連

- [ ] ✅ 全自動テストが成功（351/351 = 339 + 12）
- [ ] ✅ useLinkExistenceChecker.ts が削除されている
- [ ] ✅ usePageEditorLogic.ts に import 残存がない
- [ ] ✅ existencePluginKey への参照が削除されている
- [ ] ✅ TypeScript コンパイルエラーがない

### 動作確認

#### データ移行の確認 ⚠️ NEW

- [ ] ✅ 旧形式リンクを含むページが正常にロード
- [ ] ✅ data-page-id 属性を持つリンクが UnifiedLinkMark として認識
- [ ] ✅ data-page-title 属性を持つリンクが変換される
- [ ] ✅ 変換後のリンクがクリック可能
- [ ] ✅ 保存後、data-variant 属性が永続化
- [ ] ✅ リロード後も変換された形式が維持

#### 既存機能の確認

- [ ] ✅ ブラケットリンクの pending → exists/missing 遷移
- [ ] ✅ タグリンクの動作
- [ ] ✅ クリック時のページ遷移
- [ ] ✅ 新規ページ作成機能
- [ ] ✅ リアルタイム更新（BroadcastChannel）
- [ ] ✅ エディタの応答性（パフォーマンス劣化なし）

### パフォーマンス指標

- [ ] ✅ エディタのロード時間: 変化なし or 改善
- [ ] ✅ リンク解決速度: 変化なし or 改善
- [ ] ✅ メモリ使用量: 変化なし or 改善
- [ ] ✅ ネットワークリクエスト: 重複削除により減少
- [ ] ✅ データ変換のオーバーヘッド: 最小限

---

## 実装スケジュール（更新版）

### タイムライン

| Step | 作業内容                                  | 所要時間  | 担当   | 優先度   |
| ---- | ----------------------------------------- | --------- | ------ | -------- |
| 0.1  | **rendering.ts の parseHTML() 拡張** ⚠️   | **15 分** | Dev    | **最高** |
| 0.2  | **migration.test.ts の作成** ⚠️           | **15 分** | Dev    | **最高** |
| 0.3  | **データ移行テスト実行と修正** ⚠️         | **10 分** | Dev    | **最高** |
| 0.4  | **手動データ移行確認** ⚠️                 | **10 分** | Dev/QA | **最高** |
| 1    | usePageEditorLogic.ts - import 削除       | 2 分      | Dev    | 高       |
| 2    | usePageEditorLogic.ts - Hook 呼び出し削除 | 1 分      | Dev    | 高       |
| 3    | usePageEditorLogic.ts - savePage 処理削除 | 2 分      | Dev    | 高       |
| 4    | useLinkExistenceChecker.ts 削除           | 1 分      | Dev    | 高       |
| 5    | TypeScript コンパイル確認                 | 1 分      | Dev    | 高       |
| 6    | 自動テスト実行（351 テスト）              | 5 分      | Dev    | 高       |
| 7    | 手動動作確認（既存機能）                  | 10 分     | Dev/QA | 高       |
| 8    | パフォーマンステスト                      | 5 分      | Dev    | 中       |
| 9    | 完了レポート作成                          | 20 分     | Dev    | 高       |
| -    | **合計**                                  | **97 分** | -      | -        |

**内訳**:

- **データ移行**: 50 分（Step 0.1-0.4）
- **コード削除**: 7 分（Step 1-4）
- **検証**: 20 分（Step 5-7）
- **ドキュメント**: 20 分（Step 9）

### 実装順序（修正版）

```
Phase 3.3 実装フロー（更新版）
│
├─ [最優先] Step 0: データ移行の実装
│   ├─ 0.1: rendering.ts 修正（15分）
│   ├─ 0.2: migration.test.ts 作成（15分）
│   ├─ 0.3: テスト実行・修正（10分）
│   └─ 0.4: 手動確認（10分）
│
├─ [1] 準備
│   ├─ ブランチ確認: feature/unified-link-migration-and-tdd
│   ├─ 最新コミット取得
│   └─ 実装計画書レビュー ✅
│
├─ [2] コード削除
│   ├─ usePageEditorLogic.ts 修正（3箇所）
│   └─ useLinkExistenceChecker.ts 削除
│
├─ [3] 検証
│   ├─ TypeScript コンパイル
│   ├─ 自動テスト（339テスト）
│   └─ 手動動作確認
│
└─ [4] 完了
    ├─ 完了レポート作成
    ├─ Git コミット
    └─ Phase 3.4 準備
```

---

## Phase 3.4 への影響

### Phase 3.3 完了後の状態

```
Before Phase 3.3:
├── useLinkExistenceChecker.ts (78行)
├── usePageEditorLogic.ts
│   ├── import existencePluginKey
│   ├── import useLinkExistenceChecker
│   ├── useLinkExistenceChecker() 呼び出し
│   └── existencePluginKey 使用（savePage）
└── page-link.ts
    └── export existencePluginKey

After Phase 3.3:
├── useLinkExistenceChecker.ts ← ❌ 削除済み
├── usePageEditorLogic.ts
│   ├── import existencePluginKey ← ❌ 削除済み
│   ├── import useLinkExistenceChecker ← ❌ 削除済み
│   ├── useLinkExistenceChecker() ← ❌ 削除済み
│   └── existencePluginKey 使用 ← ❌ 削除済み
└── page-link.ts
    └── export existencePluginKey ← 参照なし（削除準備完了）
```

### Phase 3.4 の作業簡略化

#### Before Phase 3.3（従来計画）

```
Phase 3.4 削除対象:
├── page-link.ts (446行)
├── existencePluginKey（参照箇所を修正必要）
│   ├── useLinkExistenceChecker.ts ← 要修正
│   └── usePageEditorLogic.ts ← 要修正
└── useLinkExistenceChecker.ts ← 要削除
```

#### After Phase 3.3（簡略化後）

```
Phase 3.4 削除対象:
└── page-link.ts (446行) のみ
    └── existencePluginKey ← 参照箇所なし、安全に削除可能 ✅
```

**削減された作業**:

- existencePluginKey の代替実装が不要
- useLinkExistenceChecker の修正が不要
- usePageEditorLogic の修正が不要
- Phase 3.4 がシンプルな削除作業のみになる

---

## 技術的な学び

### 1. 重複機能の検出方法

**教訓**: 並行稼働期間中に以下を観察

- 両システムの出力を比較
- メトリクスで処理回数を計測
- 一方を無効化してテスト

### 2. 状態管理の設計

**Plugin Meta vs Mark 属性**:

| 特性           | Plugin Meta | Mark 属性 |
| -------------- | ----------- | --------- |
| 永続性         | ❌ 揮発性   | ✅ 永続的 |
| シリアライズ   | ❌ 不可     | ✅ 可能   |
| 検索性         | ❌ 低       | ✅ 高     |
| パフォーマンス | ✅ 高速     | ○ 良好    |

**推奨**: ドキュメントに関連する状態は Mark 属性で管理

### 3. 段階的削除の重要性

```
Phase 3.1-3.2: 新機能追加 + 並行稼働
     ↓
Phase 3.3: 重複機能削除（依存を切断）
     ↓
Phase 3.4: 本体削除（クリーンアップ）
```

**利点**:

- 各フェーズのリスクが分散
- ロールバックが容易
- 段階的な検証が可能

---

## 関連ドキュメント

### Phase 3 関連

- [Phase 3 実装計画書](./20251012_10_phase3-click-handler-migration-plan.md) - 全体計画
- [Phase 3.2 完了レポート](../../../08_worklogs/2025_10/20251012/20251012_12_phase3.2-implementation-complete.md) - 前フェーズ
- [Phase 3.3 調査レポート](../../../08_worklogs/2025_10/20251012/20251012_24_phase3.3-investigation-report.md) - 本実装の調査

### 設計ドキュメント

- [UnifiedLinkMark リファクタリング計画](./20251011_08_refactoring-plan.md)
- [移行計画書](./20251011_07_migration-plan.md)

### テスト関連

- [Integration Test 最適化](./20251012_12_integration-test-optimization.md)

---

## 付録

### A. 削除コードのバックアップ

削除前に Git でコミットを作成しておくことを推奨。

```bash
# 作業前のコミット
git add -A
git commit -m "chore: prepare for Phase 3.3 - useLinkExistenceChecker removal"

# 実装
# ... コード削除 ...

# 実装後のコミット
git add -A
git commit -m "feat: Phase 3.3 complete - remove useLinkExistenceChecker

- Remove useLinkExistenceChecker.ts (78 lines)
- Remove existencePluginKey usage from usePageEditorLogic.ts
- Remove duplicate link existence checking logic
- UnifiedLinkMark now handles all link resolution

BREAKING CHANGE: useLinkExistenceChecker hook removed
All link existence checking is now handled by UnifiedLinkMark's
automatic resolver with BroadcastChannel support.

Refs: #[issue-number]"
```

### B. エラーハンドリングガイド

#### ケース 1: テスト失敗

```bash
# テストが失敗した場合
bun test | tee test-output.log

# 失敗テストを分析
grep -A 10 "FAIL" test-output.log

# 原因調査
# - UnifiedLinkMark の動作確認
# - 削除箇所の再確認
# - 依存関係の確認
```

#### ケース 2: TypeScript エラー

```bash
# 型エラーの確認
npx tsc --noEmit

# よくあるエラー
# - existencePluginKey の import 残存
# - useLinkExistenceChecker の型参照残存
```

#### ケース 3: 実行時エラー

```javascript
// ブラウザコンソールで確認
// - "existencePluginKey is not defined"
// - "useLinkExistenceChecker is not a function"

// → 削除漏れがある可能性
// → grep 検索で全ファイルチェック
```

### C. 検証用 SQL クエリ

UnifiedLinkMark の動作を確認するための SQL:

```sql
-- ページリンクの状態確認
SELECT
  p.id,
  p.title,
  p.content->>'type' as content_type
FROM pages p
WHERE p.content::text LIKE '%unilink%'
LIMIT 10;

-- note_page_links の整合性確認
SELECT
  npl.note_id,
  npl.page_id,
  p.title
FROM note_page_links npl
JOIN pages p ON p.id = npl.page_id
WHERE npl.created_at > NOW() - INTERVAL '1 hour';
```

---

**作成日**: 2025-10-12  
**最終更新**: 2025-10-12  
**ステータス**: 実装準備完了 ✅  
**次のステップ**: 実装開始 → テスト → 完了レポート → Phase 3.4

---
